<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ravelin: LINALG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ravelin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classLINALG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LINALG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra routines.  
 <a href="classLINALG.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LinAlg_8h_source.html">LinAlg.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a864ece3a9fabc5368aec1c48234d8095"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SVD</b> { <b>eSVD1</b>, 
<b>eSVD2</b>
 }</td></tr>
<tr class="separator:a864ece3a9fabc5368aec1c48234d8095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a17ed137c3e9e3ea9916b582ac83e38c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ed137c3e9e3ea9916b582ac83e38c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a17ed137c3e9e3ea9916b582ac83e38c3">compress</a> ()</td></tr>
<tr class="memdesc:a17ed137c3e9e3ea9916b582ac83e38c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses all memory. <br/></td></tr>
<tr class="separator:a17ed137c3e9e3ea9916b582ac83e38c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe47e495cf6b47d326aea98e2d2ea825"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe47e495cf6b47d326aea98e2d2ea825"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#afe47e495cf6b47d326aea98e2d2ea825">free_memory</a> ()</td></tr>
<tr class="memdesc:afe47e495cf6b47d326aea98e2d2ea825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all allocated memory. <br/></td></tr>
<tr class="separator:afe47e495cf6b47d326aea98e2d2ea825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c976d51944c82a9ca3a80f97e4fdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2c976d51944c82a9ca3a80f97e4fdb"></a>
<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pseudo_invert</b> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:aca2c976d51944c82a9ca3a80f97e4fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a95cab878a9a35a0342a974c14ece1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a9a95cab878a9a35a0342a974c14ece1a">update_QR_rank1</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;R, const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;u, const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="memdesc:a9a95cab878a9a35a0342a974c14ece1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a QR factorization by a rank-1 update.  <a href="#a9a95cab878a9a35a0342a974c14ece1a">More...</a><br/></td></tr>
<tr class="separator:a9a95cab878a9a35a0342a974c14ece1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc452fc483cd601dc0f6a766fcf9c7d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#adc452fc483cd601dc0f6a766fcf9c7d6">update_QR_delete_cols</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="memdesc:adc452fc483cd601dc0f6a766fcf9c7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a QR factorization by deleting p columns starting at column idx k.  <a href="#adc452fc483cd601dc0f6a766fcf9c7d6">More...</a><br/></td></tr>
<tr class="separator:adc452fc483cd601dc0f6a766fcf9c7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e920ce457f8f8b3773de4f5ef9530d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a14e920ce457f8f8b3773de4f5ef9530d">update_QR_insert_cols</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, unsigned k)</td></tr>
<tr class="memdesc:a14e920ce457f8f8b3773de4f5ef9530d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a QR factorization by inserting one or more columns at column idx k.  <a href="#a14e920ce457f8f8b3773de4f5ef9530d">More...</a><br/></td></tr>
<tr class="separator:a14e920ce457f8f8b3773de4f5ef9530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403ca49ab42e12b5e280eb2e86e768b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a2403ca49ab42e12b5e280eb2e86e768b">update_QR_insert_rows</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, unsigned k)</td></tr>
<tr class="memdesc:a2403ca49ab42e12b5e280eb2e86e768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a QR factorization by inserting a block of rows, starting at index k.  <a href="#a2403ca49ab42e12b5e280eb2e86e768b">More...</a><br/></td></tr>
<tr class="separator:a2403ca49ab42e12b5e280eb2e86e768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2990ae08606a5a8e7caee43f9feed1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a2990ae08606a5a8e7caee43f9feed1d5">update_QR_delete_rows</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="memdesc:a2990ae08606a5a8e7caee43f9feed1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a QR factorization by deleting a block of rows.  <a href="#a2990ae08606a5a8e7caee43f9feed1d5">More...</a><br/></td></tr>
<tr class="separator:a2990ae08606a5a8e7caee43f9feed1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a4ccd3402d73163fe22bffc7663cc8"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a19a4ccd3402d73163fe22bffc7663cc8"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a19a4ccd3402d73163fe22bffc7663cc8">inverse_LU</a> (X &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classLINALG.html#a93782bb78164f18ae642083a20458b17">pivwork</a>)</td></tr>
<tr class="memdesc:a19a4ccd3402d73163fe22bffc7663cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix inverse using the factorization determined via <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a19a4ccd3402d73163fe22bffc7663cc8">More...</a><br/></td></tr>
<tr class="separator:a19a4ccd3402d73163fe22bffc7663cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f91fb5a760542ef7beac732db3cc1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4f91fb5a760542ef7beac732db3cc1d"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ab4f91fb5a760542ef7beac732db3cc1d"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#ab4f91fb5a760542ef7beac732db3cc1d">calc_rank</a> (X &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:ab4f91fb5a760542ef7beac732db3cc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rank of a matrix. <br/></td></tr>
<tr class="separator:ab4f91fb5a760542ef7beac732db3cc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71e4e94316fc89ee0b9e6b57d2a7fe5"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:aa71e4e94316fc89ee0b9e6b57d2a7fe5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#aa71e4e94316fc89ee0b9e6b57d2a7fe5">nullspace</a> (Y &amp;A, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;nullspace, REAL tol=-1.0)</td></tr>
<tr class="memdesc:aa71e4e94316fc89ee0b9e6b57d2a7fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of a matrix.  <a href="#aa71e4e94316fc89ee0b9e6b57d2a7fe5">More...</a><br/></td></tr>
<tr class="separator:aa71e4e94316fc89ee0b9e6b57d2a7fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fe608c8884ce95e04b69c48e5d2a5b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81fe608c8884ce95e04b69c48e5d2a5b"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a81fe608c8884ce95e04b69c48e5d2a5b"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a81fe608c8884ce95e04b69c48e5d2a5b">cond</a> (X &amp;A)</td></tr>
<tr class="memdesc:a81fe608c8884ce95e04b69c48e5d2a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the condition number of a matrix. <br/></td></tr>
<tr class="separator:a81fe608c8884ce95e04b69c48e5d2a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da52a98bb108ed9f096771d5162c336"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5da52a98bb108ed9f096771d5162c336"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a5da52a98bb108ed9f096771d5162c336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a5da52a98bb108ed9f096771d5162c336">is_SPSD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:a5da52a98bb108ed9f096771d5162c336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a symmetric matrix is positive semi-definite. <br/></td></tr>
<tr class="separator:a5da52a98bb108ed9f096771d5162c336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b25e9c7b5f1c370fde750e70e08a52"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89b25e9c7b5f1c370fde750e70e08a52"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a89b25e9c7b5f1c370fde750e70e08a52"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a89b25e9c7b5f1c370fde750e70e08a52">is_SPD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:a89b25e9c7b5f1c370fde750e70e08a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a matrix is positive-definite. <br/></td></tr>
<tr class="separator:a89b25e9c7b5f1c370fde750e70e08a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd22707fef9329711d951dd90311c2e2"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:abd22707fef9329711d951dd90311c2e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#abd22707fef9329711d951dd90311c2e2">eig_symm</a> (X &amp;A, Y &amp;evals)</td></tr>
<tr class="memdesc:abd22707fef9329711d951dd90311c2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues of the matrix A.  <a href="#abd22707fef9329711d951dd90311c2e2">More...</a><br/></td></tr>
<tr class="separator:abd22707fef9329711d951dd90311c2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794444e83a4b5b5252c189433bc7e7f1"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a794444e83a4b5b5252c189433bc7e7f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a794444e83a4b5b5252c189433bc7e7f1">eig_symm_plus</a> (X &amp;A_evecs, Y &amp;evals)</td></tr>
<tr class="memdesc:a794444e83a4b5b5252c189433bc7e7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues and eigenvectors of the matrix A.  <a href="#a794444e83a4b5b5252c189433bc7e7f1">More...</a><br/></td></tr>
<tr class="separator:a794444e83a4b5b5252c189433bc7e7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3492bb979c3c1d197fcc7fe2ddd49bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3492bb979c3c1d197fcc7fe2ddd49bb"></a>
template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:ad3492bb979c3c1d197fcc7fe2ddd49bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>svd</b> (X &amp;A, MatU &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, VecS &amp;<a class="el" href="classLINALG.html#a14e70432a83385f357cb44b95e5502d7">S</a>, MatV &amp;<a class="el" href="classLINALG.html#aa6453b886620dcc01dffd244fb520c64">V</a>)</td></tr>
<tr class="separator:ad3492bb979c3c1d197fcc7fe2ddd49bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2c91d0a5379a330f7335e109f01bbb"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:aeb2c91d0a5379a330f7335e109f01bbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#aeb2c91d0a5379a330f7335e109f01bbb">svd1</a> (X &amp;A, MatU &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, VecS &amp;<a class="el" href="classLINALG.html#a14e70432a83385f357cb44b95e5502d7">S</a>, MatV &amp;<a class="el" href="classLINALG.html#aa6453b886620dcc01dffd244fb520c64">V</a>)</td></tr>
<tr class="memdesc:aeb2c91d0a5379a330f7335e109f01bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A)  <a href="#aeb2c91d0a5379a330f7335e109f01bbb">More...</a><br/></td></tr>
<tr class="separator:aeb2c91d0a5379a330f7335e109f01bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b061238f576193960a4e40e15f46feb"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a5b061238f576193960a4e40e15f46feb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a5b061238f576193960a4e40e15f46feb">svd2</a> (X &amp;A, MatU &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, VecS &amp;<a class="el" href="classLINALG.html#a14e70432a83385f357cb44b95e5502d7">S</a>, MatV &amp;<a class="el" href="classLINALG.html#aa6453b886620dcc01dffd244fb520c64">V</a>)</td></tr>
<tr class="memdesc:a5b061238f576193960a4e40e15f46feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A), using divide and conquer algorithm.  <a href="#a5b061238f576193960a4e40e15f46feb">More...</a><br/></td></tr>
<tr class="separator:a5b061238f576193960a4e40e15f46feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1881fa49ea6c5f4d5b5d24f7d6fea5e"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af1881fa49ea6c5f4d5b5d24f7d6fea5e"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#af1881fa49ea6c5f4d5b5d24f7d6fea5e">solve_symmetric_fast</a> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:af1881fa49ea6c5f4d5b5d24f7d6fea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a symmetric, indefinite square matrix.  <a href="#af1881fa49ea6c5f4d5b5d24f7d6fea5e">More...</a><br/></td></tr>
<tr class="separator:af1881fa49ea6c5f4d5b5d24f7d6fea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10135a4958088da6a09bf8f98fa9966f"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a10135a4958088da6a09bf8f98fa9966f"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a10135a4958088da6a09bf8f98fa9966f">inverse_symmetric</a> (X &amp;A)</td></tr>
<tr class="memdesc:a10135a4958088da6a09bf8f98fa9966f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, indefinite matrix A.  <a href="#a10135a4958088da6a09bf8f98fa9966f">More...</a><br/></td></tr>
<tr class="separator:a10135a4958088da6a09bf8f98fa9966f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b405ec642518ba62e2053c2e5fe88c"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a68b405ec642518ba62e2053c2e5fe88c"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a68b405ec642518ba62e2053c2e5fe88c">invert</a> (X &amp;A)</td></tr>
<tr class="memdesc:a68b405ec642518ba62e2053c2e5fe88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the matrix A using LU factorization.  <a href="#a68b405ec642518ba62e2053c2e5fe88c">More...</a><br/></td></tr>
<tr class="separator:a68b405ec642518ba62e2053c2e5fe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f58d3601a85af95ba303e39fc27ad5"><td class="memTemplParams" colspan="2">template&lt;class X , class Y , class Vec , class Z &gt; </td></tr>
<tr class="memitem:a36f58d3601a85af95ba303e39fc27ad5"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a36f58d3601a85af95ba303e39fc27ad5">solve_LS_fast</a> (const Y &amp;<a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a>, const Vec &amp;<a class="el" href="classLINALG.html#a14e70432a83385f357cb44b95e5502d7">S</a>, const Z &amp;<a class="el" href="classLINALG.html#aa6453b886620dcc01dffd244fb520c64">V</a>, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:a36f58d3601a85af95ba303e39fc27ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#a36f58d3601a85af95ba303e39fc27ad5">More...</a><br/></td></tr>
<tr class="separator:a36f58d3601a85af95ba303e39fc27ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c7c2f222b5fdec0f244ec4dfdd1cb0"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:af5c7c2f222b5fdec0f244ec4dfdd1cb0"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#af5c7c2f222b5fdec0f244ec4dfdd1cb0">solve_LS_fast</a> (Y &amp;A, X &amp;XB, SVD svd_algo, REAL tol)</td></tr>
<tr class="memdesc:af5c7c2f222b5fdec0f244ec4dfdd1cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#af5c7c2f222b5fdec0f244ec4dfdd1cb0">More...</a><br/></td></tr>
<tr class="separator:af5c7c2f222b5fdec0f244ec4dfdd1cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45203ad484e313682b3273f75b769b6"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ad45203ad484e313682b3273f75b769b6"><td class="memTemplItemLeft" align="right" valign="top">Y &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#ad45203ad484e313682b3273f75b769b6">solve_fast</a> (X &amp;A, Y &amp;XB)</td></tr>
<tr class="memdesc:ad45203ad484e313682b3273f75b769b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the general system AX = B.  <a href="#ad45203ad484e313682b3273f75b769b6">More...</a><br/></td></tr>
<tr class="separator:ad45203ad484e313682b3273f75b769b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705a6944325c79f214d63100a8f95394"><td class="memTemplParams" colspan="2"><a class="anchor" id="a705a6944325c79f214d63100a8f95394"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a705a6944325c79f214d63100a8f95394"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast1</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a705a6944325c79f214d63100a8f95394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736faacd198419844224ad767d251e93"><td class="memTemplParams" colspan="2"><a class="anchor" id="a736faacd198419844224ad767d251e93"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a736faacd198419844224ad767d251e93"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast2</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a736faacd198419844224ad767d251e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07303d0b789bcfdfe0ccae1bda9f60d"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:aa07303d0b789bcfdfe0ccae1bda9f60d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#aa07303d0b789bcfdfe0ccae1bda9f60d">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q, std::vector&lt; int &gt; &amp;PI)</td></tr>
<tr class="memdesc:aa07303d0b789bcfdfe0ccae1bda9f60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix with column pivoting.  <a href="#aa07303d0b789bcfdfe0ccae1bda9f60d">More...</a><br/></td></tr>
<tr class="separator:aa07303d0b789bcfdfe0ccae1bda9f60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bff2bca1b2b37c7af005da58c4577d5"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:a8bff2bca1b2b37c7af005da58c4577d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a8bff2bca1b2b37c7af005da58c4577d5">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q)</td></tr>
<tr class="memdesc:a8bff2bca1b2b37c7af005da58c4577d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix.  <a href="#a8bff2bca1b2b37c7af005da58c4577d5">More...</a><br/></td></tr>
<tr class="separator:a8bff2bca1b2b37c7af005da58c4577d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a205a5a3f4c07915d62e4788d5bd57d9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205a5a3f4c07915d62e4788d5bd57d9c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>factor_LDL</b> (<a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;M, std::vector&lt; int &gt; &amp;IPIV)</td></tr>
<tr class="separator:a205a5a3f4c07915d62e4788d5bd57d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25965be0fe1e443c665c6742ed51af97"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a25965be0fe1e443c665c6742ed51af97">givens</a> (REAL a, REAL b, REAL &amp;c, REAL &amp;s)</td></tr>
<tr class="memdesc:a25965be0fe1e443c665c6742ed51af97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less robust least squares solver (solves Ax = b)  <a href="#a25965be0fe1e443c665c6742ed51af97">More...</a><br/></td></tr>
<tr class="separator:a25965be0fe1e443c665c6742ed51af97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba27b3cbf7369323d3933f1fd6f9c28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba27b3cbf7369323d3933f1fd6f9c28"></a>
static <a class="el" href="classMATRIX2.html">MATRIX2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a7ba27b3cbf7369323d3933f1fd6f9c28">givens</a> (REAL c, REAL s)</td></tr>
<tr class="memdesc:a7ba27b3cbf7369323d3933f1fd6f9c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the givens matrix given a c and s. <br/></td></tr>
<tr class="separator:a7ba27b3cbf7369323d3933f1fd6f9c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10df685a4caed956185161e52ffc41f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab10df685a4caed956185161e52ffc41f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#ab10df685a4caed956185161e52ffc41f">householder</a> (REAL alpha, const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;x, REAL &amp;tau, <a class="el" href="classVECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="memdesc:ab10df685a4caed956185161e52ffc41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a householder vector. <br/></td></tr>
<tr class="separator:ab10df685a4caed956185161e52ffc41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415564614114ee34801395f58cfe8eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415564614114ee34801395f58cfe8eec"></a>
static <a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classSPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;b, Transposition trans, <a class="el" href="classVECTORN.html">VECTORN</a> &amp;x)</td></tr>
<tr class="separator:a415564614114ee34801395f58cfe8eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8331d7991fbc07dbe4aeb721e04382e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8331d7991fbc07dbe4aeb721e04382e3"></a>
static <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classSPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;B, Transposition trans, <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;X)</td></tr>
<tr class="separator:a8331d7991fbc07dbe4aeb721e04382e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d2e1b1daa9874526b4af92894a0e96"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a45d2e1b1daa9874526b4af92894a0e96"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a45d2e1b1daa9874526b4af92894a0e96">solve_tridiagonal_fast</a> (<a class="el" href="classVECTORN.html">VECTORN</a> &amp;dl, <a class="el" href="classVECTORN.html">VECTORN</a> &amp;d, <a class="el" href="classVECTORN.html">VECTORN</a> &amp;du, X &amp;XB)</td></tr>
<tr class="memdesc:a45d2e1b1daa9874526b4af92894a0e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a tridiagonal system.  <a href="#a45d2e1b1daa9874526b4af92894a0e96">More...</a><br/></td></tr>
<tr class="separator:a45d2e1b1daa9874526b4af92894a0e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6736ada2a01c0a4c86396cf65599613e"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a6736ada2a01c0a4c86396cf65599613e"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a6736ada2a01c0a4c86396cf65599613e">factor_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a6736ada2a01c0a4c86396cf65599613e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Cholesky factorization of a matrix.  <a href="#a6736ada2a01c0a4c86396cf65599613e">More...</a><br/></td></tr>
<tr class="separator:a6736ada2a01c0a4c86396cf65599613e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd0de130258ab2d9c99c662d3f20c62"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:afcd0de130258ab2d9c99c662d3f20c62"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62">factor_LU</a> (X &amp;A, std::vector&lt; int &gt; &amp;<a class="el" href="classLINALG.html#a93782bb78164f18ae642083a20458b17">pivwork</a>)</td></tr>
<tr class="memdesc:afcd0de130258ab2d9c99c662d3f20c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the LU factorization of a matrix.  <a href="#afcd0de130258ab2d9c99c662d3f20c62">More...</a><br/></td></tr>
<tr class="separator:afcd0de130258ab2d9c99c662d3f20c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e29e91c2db8f02f872dbe3e6352c69"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:ac4e29e91c2db8f02f872dbe3e6352c69"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#ac4e29e91c2db8f02f872dbe3e6352c69">solve_tri_fast</a> (Y &amp;A, bool utri, bool transpose_A, X &amp;XB)</td></tr>
<tr class="memdesc:ac4e29e91c2db8f02f872dbe3e6352c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a triangular system of linear equations.  <a href="#ac4e29e91c2db8f02f872dbe3e6352c69">More...</a><br/></td></tr>
<tr class="separator:ac4e29e91c2db8f02f872dbe3e6352c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80be14b5665f71140229055bb70b2808"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a80be14b5665f71140229055bb70b2808"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a80be14b5665f71140229055bb70b2808">solve_LDL_fast</a> (const <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classLINALG.html#a93782bb78164f18ae642083a20458b17">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a80be14b5665f71140229055bb70b2808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves systems of linear equations using the factorization determined via factor_LDL()  <a href="#a80be14b5665f71140229055bb70b2808">More...</a><br/></td></tr>
<tr class="separator:a80be14b5665f71140229055bb70b2808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea582b89dc2d58ac5989eb95c2fdc05c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aea582b89dc2d58ac5989eb95c2fdc05c"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#aea582b89dc2d58ac5989eb95c2fdc05c">solve_chol_fast</a> (const Y &amp;M, X &amp;XB)</td></tr>
<tr class="memdesc:aea582b89dc2d58ac5989eb95c2fdc05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classLINALG.html#a6736ada2a01c0a4c86396cf65599613e" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a>  <a href="#aea582b89dc2d58ac5989eb95c2fdc05c">More...</a><br/></td></tr>
<tr class="separator:aea582b89dc2d58ac5989eb95c2fdc05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766792326395e4e6296037ea1b426bc"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a3766792326395e4e6296037ea1b426bc"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a3766792326395e4e6296037ea1b426bc">solve_LU_fast</a> (const Y &amp;M, bool transpose, const std::vector&lt; int &gt; &amp;<a class="el" href="classLINALG.html#a93782bb78164f18ae642083a20458b17">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a3766792326395e4e6296037ea1b426bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a3766792326395e4e6296037ea1b426bc">More...</a><br/></td></tr>
<tr class="separator:a3766792326395e4e6296037ea1b426bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae96a7e7f33e66422653b468b74696e3"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:aae96a7e7f33e66422653b468b74696e3"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#aae96a7e7f33e66422653b468b74696e3">solve_SPD_fast</a> (Y &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:aae96a7e7f33e66422653b468b74696e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of equations A*X = B using a symmetric, positive-definite square matrix.  <a href="#aae96a7e7f33e66422653b468b74696e3">More...</a><br/></td></tr>
<tr class="separator:aae96a7e7f33e66422653b468b74696e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931dd595780e2627b5c9a40d7c3d3b2"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a0931dd595780e2627b5c9a40d7c3d3b2"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#a0931dd595780e2627b5c9a40d7c3d3b2">inverse_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a0931dd595780e2627b5c9a40d7c3d3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#a0931dd595780e2627b5c9a40d7c3d3b2">More...</a><br/></td></tr>
<tr class="separator:a0931dd595780e2627b5c9a40d7c3d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade95892ff408c846a9cbaf82e76c1725"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:ade95892ff408c846a9cbaf82e76c1725"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLINALG.html#ade95892ff408c846a9cbaf82e76c1725">inverse_SPD</a> (X &amp;A)</td></tr>
<tr class="memdesc:ade95892ff408c846a9cbaf82e76c1725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#ade95892ff408c846a9cbaf82e76c1725">More...</a><br/></td></tr>
<tr class="separator:ade95892ff408c846a9cbaf82e76c1725"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2f1d32d91feb77743fd1b629de4d4798"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f1d32d91feb77743fd1b629de4d4798"></a>
FastThreadable&lt; <a class="el" href="classMATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a2f1d32d91feb77743fd1b629de4d4798">workM</a></td></tr>
<tr class="memdesc:a2f1d32d91feb77743fd1b629de4d4798"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrices <br/></td></tr>
<tr class="separator:a2f1d32d91feb77743fd1b629de4d4798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f47321f4190a6e57f7dc11e916d5a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84f47321f4190a6e57f7dc11e916d5a9"></a>
FastThreadable&lt; <a class="el" href="classMATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workM2</b></td></tr>
<tr class="separator:a84f47321f4190a6e57f7dc11e916d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23b8e64846290b1dd1ef714397763c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23b8e64846290b1dd1ef714397763c3"></a>
FastThreadable&lt; <a class="el" href="classMATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#ab23b8e64846290b1dd1ef714397763c3">U</a></td></tr>
<tr class="memdesc:ab23b8e64846290b1dd1ef714397763c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrix (for SVD) <br/></td></tr>
<tr class="separator:ab23b8e64846290b1dd1ef714397763c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93782bb78164f18ae642083a20458b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93782bb78164f18ae642083a20458b17"></a>
FastThreadable&lt; std::vector<br class="typebreak"/>
&lt; INTEGER &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a93782bb78164f18ae642083a20458b17">pivwork</a></td></tr>
<tr class="memdesc:a93782bb78164f18ae642083a20458b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">work STL integer vector (pivoting) <br/></td></tr>
<tr class="separator:a93782bb78164f18ae642083a20458b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6453b886620dcc01dffd244fb520c64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6453b886620dcc01dffd244fb520c64"></a>
FastThreadable&lt; <a class="el" href="classMATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#aa6453b886620dcc01dffd244fb520c64">V</a></td></tr>
<tr class="memdesc:aa6453b886620dcc01dffd244fb520c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrix (for SVD) <br/></td></tr>
<tr class="separator:aa6453b886620dcc01dffd244fb520c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e70432a83385f357cb44b95e5502d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14e70432a83385f357cb44b95e5502d7"></a>
FastThreadable&lt; <a class="el" href="classVECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a14e70432a83385f357cb44b95e5502d7">S</a></td></tr>
<tr class="memdesc:a14e70432a83385f357cb44b95e5502d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">work vector (for SVD/eigenvalues) <br/></td></tr>
<tr class="separator:a14e70432a83385f357cb44b95e5502d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57799e95f3113af43cd2463bc3208701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57799e95f3113af43cd2463bc3208701"></a>
FastThreadable&lt; <a class="el" href="classVECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a57799e95f3113af43cd2463bc3208701">workv</a></td></tr>
<tr class="memdesc:a57799e95f3113af43cd2463bc3208701"><td class="mdescLeft">&#160;</td><td class="mdescRight">work vectors (LAPACK routines) <br/></td></tr>
<tr class="separator:a57799e95f3113af43cd2463bc3208701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5836c157921dbefc58dccfa616fd1167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5836c157921dbefc58dccfa616fd1167"></a>
FastThreadable&lt; <a class="el" href="classVECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workv2</b></td></tr>
<tr class="separator:a5836c157921dbefc58dccfa616fd1167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798afed8006eaaae9a9fe645d01a8d22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798afed8006eaaae9a9fe645d01a8d22"></a>
FastThreadable&lt; std::vector<br class="typebreak"/>
&lt; INTEGER &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLINALG.html#a798afed8006eaaae9a9fe645d01a8d22">iworkv</a></td></tr>
<tr class="memdesc:a798afed8006eaaae9a9fe645d01a8d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">work STL integer vector (LAPACK routines) <br/></td></tr>
<tr class="separator:a798afed8006eaaae9a9fe645d01a8d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra routines. </p>
<p>LinAlg is a set of static routines that interface to LAPACK. I have included only very few routines here, however they should be some of the most utilized: SVD, (SVD-based) pseudo-inverse, linear equation solving, and matrix inverse. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abd22707fef9329711d951dd90311c2e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::eig_symm </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a794444e83a4b5b5252c189433bc7e7f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::eig_symm_plus </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A_evecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues and eigenvectors of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square symmetric matrix on input, eigenvectors corresponding to eigenvalues on return </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6736ada2a01c0a4c86396cf65599613e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool LINALG::factor_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the Cholesky factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix A on input; the factorized (upper triangular) matrix on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if matrix factored successfully, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="afcd0de130258ab2d9c99c662d3f20c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool LINALG::factor_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the LU factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the m x n matrix to be factored; on exit, the factors L and U from the factorization M = P*L*U (unit diagonal elements of L are not stored) </td></tr>
    <tr><td class="paramname">pivwork</td><td>on output, contains the pivot indices (for 1 &lt;= i &lt;= min(m,n), row i of A was interchanged with row pivwork[i]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if A is singular, <b>true</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa07303d0b789bcfdfe0ccae1bda9f60d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>PI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix with column pivoting. </p>
<p>Factorizes A*P = Q*R </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the matrix A on input; the matrix R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the matrix Q on output </td></tr>
    <tr><td class="paramname">PI</td><td>the column pivots on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8bff2bca1b2b37c7af005da58c4577d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the m x n matrix A on input; the matrix min(m,n) x n R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the m x min(m,n) matrix Q on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25965be0fe1e443c665c6742ed51af97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::givens </td>
          <td>(</td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less robust least squares solver (solves Ax = b) </p>
<dl class="section note"><dt>Note</dt><dd>this method does not work!Computes a givens rotation </dd></dl>

</div>
</div>
<a class="anchor" id="a0931dd595780e2627b5c9a40d7c3d3b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::inverse_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the Cholesky factorization of a matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19a4ccd3402d73163fe22bffc7663cc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::inverse_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a matrix inverse using the factorization determined via <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU-factored matrix </td></tr>
    <tr><td class="paramname">pivwork</td><td>the pivots determined by <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>throws SingularException if matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="ade95892ff408c846a9cbaf82e76c1725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::inverse_SPD </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric positive-definite matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10135a4958088da6a09bf8f98fa9966f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::inverse_symmetric </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, indefinite matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric indefinite matrix; inverse will be contained here on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68b405ec642518ba62e2053c2e5fe88c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::invert </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the matrix A using LU factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa71e4e94316fc89ee0b9e6b57d2a7fe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMATRIXN.html">MATRIXN</a>&amp; LINALG::nullspace </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>nullspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nullspace of a matrix. </p>
<dl class="section note"><dt>Note</dt><dd>A is destroyed on return </dd></dl>

</div>
</div>
<a class="anchor" id="aea582b89dc2d58ac5989eb95c2fdc05c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_chol_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classLINALG.html#a6736ada2a01c0a4c86396cf65599613e" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the Cholesky decomposition performed by <a class="el" href="classLINALG.html#a6736ada2a01c0a4c86396cf65599613e" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad45203ad484e313682b3273f75b769b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Y&amp; LINALG::solve_fast </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the general system AX = B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80be14b5665f71140229055bb70b2808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_LDL_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves systems of linear equations using the factorization determined via factor_LDL() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the factorization performed by factor_LDL() </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36f58d3601a85af95ba303e39fc27ad5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y , class Vec , class Z &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>(REAL)&#160;-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5c7c2f222b5fdec0f244ec4dfdd1cb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SVD&#160;</td>
          <td class="paramname"><em>svd_algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3766792326395e4e6296037ea1b426bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_LU_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU factorization performed by <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the matrix X on return </td></tr>
    <tr><td class="paramname">transpose</td><td>if <b>true</b>, solves M'X = B </td></tr>
    <tr><td class="paramname">pivwork</td><td>pivots computed by <a class="el" href="classLINALG.html#afcd0de130258ab2d9c99c662d3f20c62" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae96a7e7f33e66422653b468b74696e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_SPD_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of equations A*X = B using a symmetric, positive-definite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix coefficients; this matrix will be destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>on input B, on output X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1881fa49ea6c5f4d5b5d24f7d6fea5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; LINALG::solve_symmetric_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a symmetric, indefinite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix to be solved; the matrix is destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>the RHS B (A*X = B) on input; the solution, X, on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4e29e91c2db8f02f872dbe3e6352c69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_tri_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a triangular system of linear equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix </td></tr>
    <tr><td class="paramname">utri</td><td>if <b>true</b> A is upper triangular (lower triangular otherwise) </td></tr>
    <tr><td class="paramname">transpose_A</td><td>if <b>true</b>, solves A'*x = b </td></tr>
    <tr><td class="paramname">XB</td><td>contains b on entry, x on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to XB </dd></dl>

</div>
</div>
<a class="anchor" id="a45d2e1b1daa9874526b4af92894a0e96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; LINALG::solve_tridiagonal_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a tridiagonal system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dl</td><td>the (n-1) elements on the subdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">d</td><td>the n elements on the diagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">du</td><td>the n elements on the superdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the solution on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution throws SingularException if the matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="aeb2c91d0a5379a330f7335e109f01bbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::svd1 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A) </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b061238f576193960a4e40e15f46feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::svd2 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A), using divide and conquer algorithm. </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc452fc483cd601dc0f6a766fcf9c7d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::update_QR_delete_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a QR factorization by deleting p columns starting at column idx k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>a m x min(m,n) matrix </td></tr>
    <tr><td class="paramname">R</td><td>a min(m,n) x n matrix </td></tr>
    <tr><td class="paramname">k</td><td>the column index to start deleting at  p the number of columns to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2990ae08606a5a8e7caee43f9feed1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::update_QR_delete_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a QR factorization by deleting a block of rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>a m x min(m,n) matrix </td></tr>
    <tr><td class="paramname">R</td><td>a min(m,n) x n matrix </td></tr>
    <tr><td class="paramname">k</td><td>the index to start deleting at </td></tr>
    <tr><td class="paramname">p</td><td>the number of rows to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14e920ce457f8f8b3773de4f5ef9530d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::update_QR_insert_cols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a QR factorization by inserting one or more columns at column idx k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>a m x min(m,n) matrix </td></tr>
    <tr><td class="paramname">R</td><td>a min(m,n) x n matrix </td></tr>
    <tr><td class="paramname">U</td><td>a m x p matrix, destroyed on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2403ca49ab42e12b5e280eb2e86e768b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::update_QR_insert_rows </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a QR factorization by inserting a block of rows, starting at index k. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>a m x min(m,n) matrix </td></tr>
    <tr><td class="paramname">R</td><td>a min(m,n) x n matrix </td></tr>
    <tr><td class="paramname">U</td><td>a p x n matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">k</td><td>the index to insert at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a95cab878a9a35a0342a974c14ece1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LINALG::update_QR_rank1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a QR factorization by a rank-1 update. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>a m x min(m,n) matrix </td></tr>
    <tr><td class="paramname">R</td><td>a min(m,n) x n matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/drum/Ravelin.new/include/Ravelin/<a class="el" href="LinAlg_8h_source.html">LinAlg.h</a></li>
<li>/home/drum/Ravelin.new/src/LinAlg.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 9 2016 11:34:04 for Ravelin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
