<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Ravelin: Ravelin::LINALG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ravelin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRavelin.html">Ravelin</a></li><li class="navelem"><a class="el" href="classRavelin_1_1LINALG.html">LINALG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classRavelin_1_1LINALG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ravelin::LINALG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Linear algebra routines.  
 <a href="classRavelin_1_1LINALG.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LinAlgd_8h_source.html">LinAlgd.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4a7f0f5574ddb2ab3649606719b1fa93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SVD</b> { <b>eSVD1</b>, 
<b>eSVD2</b>, 
<b>eSVD1</b>, 
<b>eSVD2</b>
 }</td></tr>
<tr class="separator:a4a7f0f5574ddb2ab3649606719b1fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7f0f5574ddb2ab3649606719b1fa93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>SVD</b> { <b>eSVD1</b>, 
<b>eSVD2</b>, 
<b>eSVD1</b>, 
<b>eSVD2</b>
 }</td></tr>
<tr class="separator:a4a7f0f5574ddb2ab3649606719b1fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d132e23a29f40dc4ea570137a8fefd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d132e23a29f40dc4ea570137a8fefd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compress</b> ()</td></tr>
<tr class="separator:a1d132e23a29f40dc4ea570137a8fefd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f25de57c1830f92777e0c8f43038b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3f25de57c1830f92777e0c8f43038b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_memory</b> ()</td></tr>
<tr class="separator:adc3f25de57c1830f92777e0c8f43038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2eb1da31fd9a0df382361646c52327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2eb1da31fd9a0df382361646c52327"></a>
<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pseudo_invert</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a1d2eb1da31fd9a0df382361646c52327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e0ad730a36d98d313f4f0eaa320a64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e0ad730a36d98d313f4f0eaa320a64"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_rank1</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;u, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="separator:a28e0ad730a36d98d313f4f0eaa320a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182726f5fff77b421deabb961a2cdf28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a182726f5fff77b421deabb961a2cdf28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_delete_cols</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="separator:a182726f5fff77b421deabb961a2cdf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25408c5a48b50fca4147e507b514a4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25408c5a48b50fca4147e507b514a4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_insert_cols</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, unsigned k)</td></tr>
<tr class="separator:ac25408c5a48b50fca4147e507b514a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e48820b8ea012d32d876bce444855c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e48820b8ea012d32d876bce444855c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_insert_rows</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, unsigned k)</td></tr>
<tr class="separator:a93e48820b8ea012d32d876bce444855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f964103a03d122d328af2583a2127d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f964103a03d122d328af2583a2127d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_delete_rows</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="separator:a54f964103a03d122d328af2583a2127d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63829e76a2aa425ffe758e4c839fb587"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a63829e76a2aa425ffe758e4c839fb587"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a63829e76a2aa425ffe758e4c839fb587">inverse_LU</a> (X &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>)</td></tr>
<tr class="memdesc:a63829e76a2aa425ffe758e4c839fb587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix inverse using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a63829e76a2aa425ffe758e4c839fb587">More...</a><br/></td></tr>
<tr class="separator:a63829e76a2aa425ffe758e4c839fb587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53de6032657d549f7c2e86c2ce82fe89"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53de6032657d549f7c2e86c2ce82fe89"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a53de6032657d549f7c2e86c2ce82fe89"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a53de6032657d549f7c2e86c2ce82fe89">calc_rank</a> (X &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:a53de6032657d549f7c2e86c2ce82fe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rank of a matrix. <br/></td></tr>
<tr class="separator:a53de6032657d549f7c2e86c2ce82fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31076b4febea7112684caa16ce1b429"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ab31076b4febea7112684caa16ce1b429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ab31076b4febea7112684caa16ce1b429">nullspace</a> (Y &amp;A, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;nullspace, REAL tol=-1.0)</td></tr>
<tr class="memdesc:ab31076b4febea7112684caa16ce1b429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of a matrix.  <a href="#ab31076b4febea7112684caa16ce1b429">More...</a><br/></td></tr>
<tr class="separator:ab31076b4febea7112684caa16ce1b429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42183beac9a0a12c5cd240a20e58349"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab42183beac9a0a12c5cd240a20e58349"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ab42183beac9a0a12c5cd240a20e58349"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ab42183beac9a0a12c5cd240a20e58349">cond</a> (X &amp;A)</td></tr>
<tr class="memdesc:ab42183beac9a0a12c5cd240a20e58349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the condition number of a matrix. <br/></td></tr>
<tr class="separator:ab42183beac9a0a12c5cd240a20e58349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3353414935b7367ed572fc2c5f8de3d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3353414935b7367ed572fc2c5f8de3d4"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a3353414935b7367ed572fc2c5f8de3d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a3353414935b7367ed572fc2c5f8de3d4">is_SPSD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:a3353414935b7367ed572fc2c5f8de3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a symmetric matrix is positive semi-definite. <br/></td></tr>
<tr class="separator:a3353414935b7367ed572fc2c5f8de3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3e824cbf527fcfefcf4f7937cdf50df"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac3e824cbf527fcfefcf4f7937cdf50df">is_SPD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a matrix is positive-definite. <br/></td></tr>
<tr class="separator:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce23867c57939239cb95d9428ef324"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a4cce23867c57939239cb95d9428ef324"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a4cce23867c57939239cb95d9428ef324">eig_symm</a> (X &amp;A, Y &amp;evals)</td></tr>
<tr class="memdesc:a4cce23867c57939239cb95d9428ef324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues of the matrix A.  <a href="#a4cce23867c57939239cb95d9428ef324">More...</a><br/></td></tr>
<tr class="separator:a4cce23867c57939239cb95d9428ef324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a723477d6c49be0a165d87421ad1b"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a421a723477d6c49be0a165d87421ad1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a421a723477d6c49be0a165d87421ad1b">eig_symm_plus</a> (X &amp;A_evecs, Y &amp;evals)</td></tr>
<tr class="memdesc:a421a723477d6c49be0a165d87421ad1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues and eigenvectors of the matrix A.  <a href="#a421a723477d6c49be0a165d87421ad1b">More...</a><br/></td></tr>
<tr class="separator:a421a723477d6c49be0a165d87421ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d4e8c7fc4e95b3e50ff0a3440f05623"></a>
template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>svd</b> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="separator:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d558061ab8c4992263e19699e9f028"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a55d558061ab8c4992263e19699e9f028"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a55d558061ab8c4992263e19699e9f028">svd1</a> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="memdesc:a55d558061ab8c4992263e19699e9f028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A)  <a href="#a55d558061ab8c4992263e19699e9f028">More...</a><br/></td></tr>
<tr class="separator:a55d558061ab8c4992263e19699e9f028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e15257393585700d63837be294947"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a0c1e15257393585700d63837be294947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a0c1e15257393585700d63837be294947">svd2</a> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="memdesc:a0c1e15257393585700d63837be294947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A), using divide and conquer algorithm.  <a href="#a0c1e15257393585700d63837be294947">More...</a><br/></td></tr>
<tr class="separator:a0c1e15257393585700d63837be294947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ab0e0f1e84082845b04ced2ffb028"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a691ab0e0f1e84082845b04ced2ffb028"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a691ab0e0f1e84082845b04ced2ffb028">solve_symmetric_fast</a> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:a691ab0e0f1e84082845b04ced2ffb028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a symmetric, indefinite square matrix.  <a href="#a691ab0e0f1e84082845b04ced2ffb028">More...</a><br/></td></tr>
<tr class="separator:a691ab0e0f1e84082845b04ced2ffb028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a43e0ec1fe8292d9e201c5af1b69ad3a8">inverse_symmetric</a> (X &amp;A)</td></tr>
<tr class="memdesc:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, indefinite matrix A.  <a href="#a43e0ec1fe8292d9e201c5af1b69ad3a8">More...</a><br/></td></tr>
<tr class="separator:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b9e0c17e94c903516a33a109d434e1"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:ac7b9e0c17e94c903516a33a109d434e1"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac7b9e0c17e94c903516a33a109d434e1">invert</a> (X &amp;A)</td></tr>
<tr class="memdesc:ac7b9e0c17e94c903516a33a109d434e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the matrix A using LU factorization.  <a href="#ac7b9e0c17e94c903516a33a109d434e1">More...</a><br/></td></tr>
<tr class="separator:ac7b9e0c17e94c903516a33a109d434e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memTemplParams" colspan="2">template&lt;class X , class Y , class Vec , class Z &gt; </td></tr>
<tr class="memitem:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ad16e124bf2b16f8d796d4d81c59f0412">solve_LS_fast</a> (const Y &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, const Vec &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, const Z &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:ad16e124bf2b16f8d796d4d81c59f0412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#ad16e124bf2b16f8d796d4d81c59f0412">More...</a><br/></td></tr>
<tr class="separator:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257c49da86397d54e6687e98c2af53fd"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a257c49da86397d54e6687e98c2af53fd"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a257c49da86397d54e6687e98c2af53fd">solve_LS_fast</a> (Y &amp;A, X &amp;XB, SVD svd_algo, REAL tol)</td></tr>
<tr class="memdesc:a257c49da86397d54e6687e98c2af53fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#a257c49da86397d54e6687e98c2af53fd">More...</a><br/></td></tr>
<tr class="separator:a257c49da86397d54e6687e98c2af53fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489a0d62b0192872b88e9754fc8c145c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a489a0d62b0192872b88e9754fc8c145c"><td class="memTemplItemLeft" align="right" valign="top">Y &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a489a0d62b0192872b88e9754fc8c145c">solve_fast</a> (X &amp;A, Y &amp;XB)</td></tr>
<tr class="memdesc:a489a0d62b0192872b88e9754fc8c145c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the general system AX = B.  <a href="#a489a0d62b0192872b88e9754fc8c145c">More...</a><br/></td></tr>
<tr class="separator:a489a0d62b0192872b88e9754fc8c145c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89b4e4fbb4024f1254a7f31d959fee60"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast1</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceadda7269be1828b7fd2503bc5454fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="aceadda7269be1828b7fd2503bc5454fe"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aceadda7269be1828b7fd2503bc5454fe"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast2</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:aceadda7269be1828b7fd2503bc5454fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3caea18d7a91a311635e86f62c28bcd"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:ac3caea18d7a91a311635e86f62c28bcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac3caea18d7a91a311635e86f62c28bcd">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q, std::vector&lt; int &gt; &amp;PI)</td></tr>
<tr class="memdesc:ac3caea18d7a91a311635e86f62c28bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix with column pivoting.  <a href="#ac3caea18d7a91a311635e86f62c28bcd">More...</a><br/></td></tr>
<tr class="separator:ac3caea18d7a91a311635e86f62c28bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09095d33d0b06a94b3ef08322ec53dee"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:a09095d33d0b06a94b3ef08322ec53dee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a09095d33d0b06a94b3ef08322ec53dee">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q)</td></tr>
<tr class="memdesc:a09095d33d0b06a94b3ef08322ec53dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix.  <a href="#a09095d33d0b06a94b3ef08322ec53dee">More...</a><br/></td></tr>
<tr class="separator:a09095d33d0b06a94b3ef08322ec53dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d132e23a29f40dc4ea570137a8fefd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d132e23a29f40dc4ea570137a8fefd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compress</b> ()</td></tr>
<tr class="separator:a1d132e23a29f40dc4ea570137a8fefd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3f25de57c1830f92777e0c8f43038b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3f25de57c1830f92777e0c8f43038b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_memory</b> ()</td></tr>
<tr class="separator:adc3f25de57c1830f92777e0c8f43038b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2eb1da31fd9a0df382361646c52327"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2eb1da31fd9a0df382361646c52327"></a>
<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>pseudo_invert</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a1d2eb1da31fd9a0df382361646c52327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e0ad730a36d98d313f4f0eaa320a64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e0ad730a36d98d313f4f0eaa320a64"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_rank1</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;u, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="separator:a28e0ad730a36d98d313f4f0eaa320a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182726f5fff77b421deabb961a2cdf28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a182726f5fff77b421deabb961a2cdf28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_delete_cols</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="separator:a182726f5fff77b421deabb961a2cdf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25408c5a48b50fca4147e507b514a4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25408c5a48b50fca4147e507b514a4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_insert_cols</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, unsigned k)</td></tr>
<tr class="separator:ac25408c5a48b50fca4147e507b514a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e48820b8ea012d32d876bce444855c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e48820b8ea012d32d876bce444855c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_insert_rows</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, unsigned k)</td></tr>
<tr class="separator:a93e48820b8ea012d32d876bce444855c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f964103a03d122d328af2583a2127d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f964103a03d122d328af2583a2127d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_QR_delete_rows</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;Q, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;R, unsigned k, unsigned p)</td></tr>
<tr class="separator:a54f964103a03d122d328af2583a2127d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63829e76a2aa425ffe758e4c839fb587"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a63829e76a2aa425ffe758e4c839fb587"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a63829e76a2aa425ffe758e4c839fb587">inverse_LU</a> (X &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>)</td></tr>
<tr class="memdesc:a63829e76a2aa425ffe758e4c839fb587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a matrix inverse using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a63829e76a2aa425ffe758e4c839fb587">More...</a><br/></td></tr>
<tr class="separator:a63829e76a2aa425ffe758e4c839fb587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53de6032657d549f7c2e86c2ce82fe89"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53de6032657d549f7c2e86c2ce82fe89"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a53de6032657d549f7c2e86c2ce82fe89"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a53de6032657d549f7c2e86c2ce82fe89">calc_rank</a> (X &amp;A, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:a53de6032657d549f7c2e86c2ce82fe89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rank of a matrix. <br/></td></tr>
<tr class="separator:a53de6032657d549f7c2e86c2ce82fe89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31076b4febea7112684caa16ce1b429"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ab31076b4febea7112684caa16ce1b429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ab31076b4febea7112684caa16ce1b429">nullspace</a> (Y &amp;A, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;nullspace, REAL tol=-1.0)</td></tr>
<tr class="memdesc:ab31076b4febea7112684caa16ce1b429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the nullspace of a matrix.  <a href="#ab31076b4febea7112684caa16ce1b429">More...</a><br/></td></tr>
<tr class="separator:ab31076b4febea7112684caa16ce1b429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42183beac9a0a12c5cd240a20e58349"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab42183beac9a0a12c5cd240a20e58349"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ab42183beac9a0a12c5cd240a20e58349"><td class="memTemplItemLeft" align="right" valign="top">REAL&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ab42183beac9a0a12c5cd240a20e58349">cond</a> (X &amp;A)</td></tr>
<tr class="memdesc:ab42183beac9a0a12c5cd240a20e58349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the condition number of a matrix. <br/></td></tr>
<tr class="separator:ab42183beac9a0a12c5cd240a20e58349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3353414935b7367ed572fc2c5f8de3d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3353414935b7367ed572fc2c5f8de3d4"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a3353414935b7367ed572fc2c5f8de3d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a3353414935b7367ed572fc2c5f8de3d4">is_SPSD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:a3353414935b7367ed572fc2c5f8de3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a symmetric matrix is positive semi-definite. <br/></td></tr>
<tr class="separator:a3353414935b7367ed572fc2c5f8de3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3e824cbf527fcfefcf4f7937cdf50df"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac3e824cbf527fcfefcf4f7937cdf50df">is_SPD</a> (X &amp;m, REAL tol)</td></tr>
<tr class="memdesc:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a matrix is positive-definite. <br/></td></tr>
<tr class="separator:ac3e824cbf527fcfefcf4f7937cdf50df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce23867c57939239cb95d9428ef324"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a4cce23867c57939239cb95d9428ef324"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a4cce23867c57939239cb95d9428ef324">eig_symm</a> (X &amp;A, Y &amp;evals)</td></tr>
<tr class="memdesc:a4cce23867c57939239cb95d9428ef324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues of the matrix A.  <a href="#a4cce23867c57939239cb95d9428ef324">More...</a><br/></td></tr>
<tr class="separator:a4cce23867c57939239cb95d9428ef324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421a723477d6c49be0a165d87421ad1b"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a421a723477d6c49be0a165d87421ad1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a421a723477d6c49be0a165d87421ad1b">eig_symm_plus</a> (X &amp;A_evecs, Y &amp;evals)</td></tr>
<tr class="memdesc:a421a723477d6c49be0a165d87421ad1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the eigenvalues and eigenvectors of the matrix A.  <a href="#a421a723477d6c49be0a165d87421ad1b">More...</a><br/></td></tr>
<tr class="separator:a421a723477d6c49be0a165d87421ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d4e8c7fc4e95b3e50ff0a3440f05623"></a>
template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>svd</b> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="separator:a3d4e8c7fc4e95b3e50ff0a3440f05623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d558061ab8c4992263e19699e9f028"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a55d558061ab8c4992263e19699e9f028"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a55d558061ab8c4992263e19699e9f028">svd1</a> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="memdesc:a55d558061ab8c4992263e19699e9f028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A)  <a href="#a55d558061ab8c4992263e19699e9f028">More...</a><br/></td></tr>
<tr class="separator:a55d558061ab8c4992263e19699e9f028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e15257393585700d63837be294947"><td class="memTemplParams" colspan="2">template&lt;class X , class MatU , class VecS , class MatV &gt; </td></tr>
<tr class="memitem:a0c1e15257393585700d63837be294947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a0c1e15257393585700d63837be294947">svd2</a> (X &amp;A, MatU &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, VecS &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, MatV &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>)</td></tr>
<tr class="memdesc:a0c1e15257393585700d63837be294947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does an 'in place' SVD (destroying A), using divide and conquer algorithm.  <a href="#a0c1e15257393585700d63837be294947">More...</a><br/></td></tr>
<tr class="separator:a0c1e15257393585700d63837be294947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ab0e0f1e84082845b04ced2ffb028"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a691ab0e0f1e84082845b04ced2ffb028"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a691ab0e0f1e84082845b04ced2ffb028">solve_symmetric_fast</a> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:a691ab0e0f1e84082845b04ced2ffb028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a symmetric, indefinite square matrix.  <a href="#a691ab0e0f1e84082845b04ced2ffb028">More...</a><br/></td></tr>
<tr class="separator:a691ab0e0f1e84082845b04ced2ffb028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a43e0ec1fe8292d9e201c5af1b69ad3a8">inverse_symmetric</a> (X &amp;A)</td></tr>
<tr class="memdesc:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, indefinite matrix A.  <a href="#a43e0ec1fe8292d9e201c5af1b69ad3a8">More...</a><br/></td></tr>
<tr class="separator:a43e0ec1fe8292d9e201c5af1b69ad3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b9e0c17e94c903516a33a109d434e1"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:ac7b9e0c17e94c903516a33a109d434e1"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac7b9e0c17e94c903516a33a109d434e1">invert</a> (X &amp;A)</td></tr>
<tr class="memdesc:ac7b9e0c17e94c903516a33a109d434e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the matrix A using LU factorization.  <a href="#ac7b9e0c17e94c903516a33a109d434e1">More...</a><br/></td></tr>
<tr class="separator:ac7b9e0c17e94c903516a33a109d434e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memTemplParams" colspan="2">template&lt;class X , class Y , class Vec , class Z &gt; </td></tr>
<tr class="memitem:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ad16e124bf2b16f8d796d4d81c59f0412">solve_LS_fast</a> (const Y &amp;<a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a>, const Vec &amp;<a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a>, const Z &amp;<a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a>, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="memdesc:ad16e124bf2b16f8d796d4d81c59f0412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#ad16e124bf2b16f8d796d4d81c59f0412">More...</a><br/></td></tr>
<tr class="separator:ad16e124bf2b16f8d796d4d81c59f0412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257c49da86397d54e6687e98c2af53fd"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a257c49da86397d54e6687e98c2af53fd"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a257c49da86397d54e6687e98c2af53fd">solve_LS_fast</a> (Y &amp;A, X &amp;XB, SVD svd_algo, REAL tol)</td></tr>
<tr class="memdesc:a257c49da86397d54e6687e98c2af53fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most robust system of linear equations solver (solves AX = B)  <a href="#a257c49da86397d54e6687e98c2af53fd">More...</a><br/></td></tr>
<tr class="separator:a257c49da86397d54e6687e98c2af53fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489a0d62b0192872b88e9754fc8c145c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a489a0d62b0192872b88e9754fc8c145c"><td class="memTemplItemLeft" align="right" valign="top">Y &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a489a0d62b0192872b88e9754fc8c145c">solve_fast</a> (X &amp;A, Y &amp;XB)</td></tr>
<tr class="memdesc:a489a0d62b0192872b88e9754fc8c145c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the general system AX = B.  <a href="#a489a0d62b0192872b88e9754fc8c145c">More...</a><br/></td></tr>
<tr class="separator:a489a0d62b0192872b88e9754fc8c145c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89b4e4fbb4024f1254a7f31d959fee60"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast1</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:a89b4e4fbb4024f1254a7f31d959fee60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceadda7269be1828b7fd2503bc5454fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="aceadda7269be1828b7fd2503bc5454fe"></a>
template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aceadda7269be1828b7fd2503bc5454fe"><td class="memTemplItemLeft" align="right" valign="top">X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve_LS_fast2</b> (Y &amp;A, X &amp;XB, REAL tol=(REAL)-1.0)</td></tr>
<tr class="separator:aceadda7269be1828b7fd2503bc5454fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3caea18d7a91a311635e86f62c28bcd"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:ac3caea18d7a91a311635e86f62c28bcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac3caea18d7a91a311635e86f62c28bcd">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q, std::vector&lt; int &gt; &amp;PI)</td></tr>
<tr class="memdesc:ac3caea18d7a91a311635e86f62c28bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix with column pivoting.  <a href="#ac3caea18d7a91a311635e86f62c28bcd">More...</a><br/></td></tr>
<tr class="separator:ac3caea18d7a91a311635e86f62c28bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09095d33d0b06a94b3ef08322ec53dee"><td class="memTemplParams" colspan="2">template&lt;class ARMat , class QMat &gt; </td></tr>
<tr class="memitem:a09095d33d0b06a94b3ef08322ec53dee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a09095d33d0b06a94b3ef08322ec53dee">factor_QR</a> (ARMat &amp;AR, QMat &amp;Q)</td></tr>
<tr class="memdesc:a09095d33d0b06a94b3ef08322ec53dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the QR factorization of a matrix.  <a href="#a09095d33d0b06a94b3ef08322ec53dee">More...</a><br/></td></tr>
<tr class="separator:a09095d33d0b06a94b3ef08322ec53dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad80c84374082f14a5698a02680efbfa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad80c84374082f14a5698a02680efbfa3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>factor_LDL</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;M, std::vector&lt; int &gt; &amp;IPIV)</td></tr>
<tr class="separator:ad80c84374082f14a5698a02680efbfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d1a698fd6380e19befda0d44f4146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e0d1a698fd6380e19befda0d44f4146"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>givens</b> (REAL a, REAL b, REAL &amp;c, REAL &amp;s)</td></tr>
<tr class="separator:a4e0d1a698fd6380e19befda0d44f4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e95f8075d6f67ccc72d942c69aaae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e95f8075d6f67ccc72d942c69aaae6"></a>
static <a class="el" href="classRavelin_1_1MATRIX2.html">MATRIX2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>givens</b> (REAL c, REAL s)</td></tr>
<tr class="separator:a15e95f8075d6f67ccc72d942c69aaae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08d146321031cf8b118fbba17e1e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb08d146321031cf8b118fbba17e1e71"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>householder</b> (REAL alpha, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;x, REAL &amp;tau, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="separator:aeb08d146321031cf8b118fbba17e1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7323b57379e87eb8108f848c63cf1b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7323b57379e87eb8108f848c63cf1b3"></a>
static <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classRavelin_1_1SPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;b, Transposition trans, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;x)</td></tr>
<tr class="separator:aa7323b57379e87eb8108f848c63cf1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4a96d960eeee8b4ee45dff6711dcd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4a96d960eeee8b4ee45dff6711dcd3"></a>
static <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classRavelin_1_1SPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;B, Transposition trans, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;X)</td></tr>
<tr class="separator:a2d4a96d960eeee8b4ee45dff6711dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f19314b8bb550e4fec001c1638742c"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af6f19314b8bb550e4fec001c1638742c"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#af6f19314b8bb550e4fec001c1638742c">solve_tridiagonal_fast</a> (<a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;dl, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;d, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;du, X &amp;XB)</td></tr>
<tr class="memdesc:af6f19314b8bb550e4fec001c1638742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a tridiagonal system.  <a href="#af6f19314b8bb550e4fec001c1638742c">More...</a><br/></td></tr>
<tr class="separator:af6f19314b8bb550e4fec001c1638742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96c22a3b9c0694210078a38798f56a"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a1b96c22a3b9c0694210078a38798f56a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a">factor_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a1b96c22a3b9c0694210078a38798f56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Cholesky factorization of a matrix.  <a href="#a1b96c22a3b9c0694210078a38798f56a">More...</a><br/></td></tr>
<tr class="separator:a1b96c22a3b9c0694210078a38798f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad92632041940ca3d948b55367baa3c"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a8ad92632041940ca3d948b55367baa3c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c">factor_LU</a> (X &amp;A, std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>)</td></tr>
<tr class="memdesc:a8ad92632041940ca3d948b55367baa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the LU factorization of a matrix.  <a href="#a8ad92632041940ca3d948b55367baa3c">More...</a><br/></td></tr>
<tr class="separator:a8ad92632041940ca3d948b55367baa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#abed5ecdd3ed3a1215d02d4b2597fe1d1">solve_tri_fast</a> (Y &amp;A, bool utri, bool transpose_A, X &amp;XB)</td></tr>
<tr class="memdesc:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a triangular system of linear equations.  <a href="#abed5ecdd3ed3a1215d02d4b2597fe1d1">More...</a><br/></td></tr>
<tr class="separator:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a83420fa6d087a3b62c1ddd510a2a6fd0">solve_LDL_fast</a> (const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves systems of linear equations using the factorization determined via factor_LDL()  <a href="#a83420fa6d087a3b62c1ddd510a2a6fd0">More...</a><br/></td></tr>
<tr class="separator:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#aa8e40ab11ab89d1041f9ffbe25131901">solve_chol_fast</a> (const Y &amp;M, X &amp;XB)</td></tr>
<tr class="memdesc:aa8e40ab11ab89d1041f9ffbe25131901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a>  <a href="#aa8e40ab11ab89d1041f9ffbe25131901">More...</a><br/></td></tr>
<tr class="separator:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a3e2ff962b1fcc9df4a7411681bbbd901">solve_LU_fast</a> (const Y &amp;M, bool transpose, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a3e2ff962b1fcc9df4a7411681bbbd901">More...</a><br/></td></tr>
<tr class="separator:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91f90a5921fd6d630930b79673d3bd4"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:ac91f90a5921fd6d630930b79673d3bd4"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac91f90a5921fd6d630930b79673d3bd4">solve_SPD_fast</a> (Y &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:ac91f90a5921fd6d630930b79673d3bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of equations A*X = B using a symmetric, positive-definite square matrix.  <a href="#ac91f90a5921fd6d630930b79673d3bd4">More...</a><br/></td></tr>
<tr class="separator:ac91f90a5921fd6d630930b79673d3bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a4fe9a133da033dadfa7d807c7c1bea8e">inverse_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#a4fe9a133da033dadfa7d807c7c1bea8e">More...</a><br/></td></tr>
<tr class="separator:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#af58ae9a2c9bc2666f7b1acda0d3c10d9">inverse_SPD</a> (X &amp;A)</td></tr>
<tr class="memdesc:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#af58ae9a2c9bc2666f7b1acda0d3c10d9">More...</a><br/></td></tr>
<tr class="separator:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80c84374082f14a5698a02680efbfa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad80c84374082f14a5698a02680efbfa3"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>factor_LDL</b> (<a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;M, std::vector&lt; int &gt; &amp;IPIV)</td></tr>
<tr class="separator:ad80c84374082f14a5698a02680efbfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0d1a698fd6380e19befda0d44f4146"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e0d1a698fd6380e19befda0d44f4146"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>givens</b> (REAL a, REAL b, REAL &amp;c, REAL &amp;s)</td></tr>
<tr class="separator:a4e0d1a698fd6380e19befda0d44f4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e95f8075d6f67ccc72d942c69aaae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e95f8075d6f67ccc72d942c69aaae6"></a>
static <a class="el" href="classRavelin_1_1MATRIX2.html">MATRIX2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>givens</b> (REAL c, REAL s)</td></tr>
<tr class="separator:a15e95f8075d6f67ccc72d942c69aaae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb08d146321031cf8b118fbba17e1e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb08d146321031cf8b118fbba17e1e71"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>householder</b> (REAL alpha, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;x, REAL &amp;tau, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;v)</td></tr>
<tr class="separator:aeb08d146321031cf8b118fbba17e1e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7323b57379e87eb8108f848c63cf1b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7323b57379e87eb8108f848c63cf1b3"></a>
static <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classRavelin_1_1SPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;b, Transposition trans, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;x)</td></tr>
<tr class="separator:aa7323b57379e87eb8108f848c63cf1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4a96d960eeee8b4ee45dff6711dcd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4a96d960eeee8b4ee45dff6711dcd3"></a>
static <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>solve_sparse_direct</b> (const <a class="el" href="classRavelin_1_1SPARSEMATRIXN.html">SPARSEMATRIXN</a> &amp;A, const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;B, Transposition trans, <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;X)</td></tr>
<tr class="separator:a2d4a96d960eeee8b4ee45dff6711dcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f19314b8bb550e4fec001c1638742c"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af6f19314b8bb550e4fec001c1638742c"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#af6f19314b8bb550e4fec001c1638742c">solve_tridiagonal_fast</a> (<a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;dl, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;d, <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;du, X &amp;XB)</td></tr>
<tr class="memdesc:af6f19314b8bb550e4fec001c1638742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a tridiagonal system.  <a href="#af6f19314b8bb550e4fec001c1638742c">More...</a><br/></td></tr>
<tr class="separator:af6f19314b8bb550e4fec001c1638742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b96c22a3b9c0694210078a38798f56a"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a1b96c22a3b9c0694210078a38798f56a"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a">factor_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a1b96c22a3b9c0694210078a38798f56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Cholesky factorization of a matrix.  <a href="#a1b96c22a3b9c0694210078a38798f56a">More...</a><br/></td></tr>
<tr class="separator:a1b96c22a3b9c0694210078a38798f56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad92632041940ca3d948b55367baa3c"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a8ad92632041940ca3d948b55367baa3c"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c">factor_LU</a> (X &amp;A, std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>)</td></tr>
<tr class="memdesc:a8ad92632041940ca3d948b55367baa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the LU factorization of a matrix.  <a href="#a8ad92632041940ca3d948b55367baa3c">More...</a><br/></td></tr>
<tr class="separator:a8ad92632041940ca3d948b55367baa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#abed5ecdd3ed3a1215d02d4b2597fe1d1">solve_tri_fast</a> (Y &amp;A, bool utri, bool transpose_A, X &amp;XB)</td></tr>
<tr class="memdesc:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a triangular system of linear equations.  <a href="#abed5ecdd3ed3a1215d02d4b2597fe1d1">More...</a><br/></td></tr>
<tr class="separator:abed5ecdd3ed3a1215d02d4b2597fe1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a83420fa6d087a3b62c1ddd510a2a6fd0">solve_LDL_fast</a> (const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;M, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves systems of linear equations using the factorization determined via factor_LDL()  <a href="#a83420fa6d087a3b62c1ddd510a2a6fd0">More...</a><br/></td></tr>
<tr class="separator:a83420fa6d087a3b62c1ddd510a2a6fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#aa8e40ab11ab89d1041f9ffbe25131901">solve_chol_fast</a> (const Y &amp;M, X &amp;XB)</td></tr>
<tr class="memdesc:aa8e40ab11ab89d1041f9ffbe25131901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a>  <a href="#aa8e40ab11ab89d1041f9ffbe25131901">More...</a><br/></td></tr>
<tr class="separator:aa8e40ab11ab89d1041f9ffbe25131901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a3e2ff962b1fcc9df4a7411681bbbd901">solve_LU_fast</a> (const Y &amp;M, bool transpose, const std::vector&lt; int &gt; &amp;<a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a>, X &amp;XB)</td></tr>
<tr class="memdesc:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a>  <a href="#a3e2ff962b1fcc9df4a7411681bbbd901">More...</a><br/></td></tr>
<tr class="separator:a3e2ff962b1fcc9df4a7411681bbbd901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91f90a5921fd6d630930b79673d3bd4"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:ac91f90a5921fd6d630930b79673d3bd4"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ac91f90a5921fd6d630930b79673d3bd4">solve_SPD_fast</a> (Y &amp;A, X &amp;XB)</td></tr>
<tr class="memdesc:ac91f90a5921fd6d630930b79673d3bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of equations A*X = B using a symmetric, positive-definite square matrix.  <a href="#ac91f90a5921fd6d630930b79673d3bd4">More...</a><br/></td></tr>
<tr class="separator:ac91f90a5921fd6d630930b79673d3bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a4fe9a133da033dadfa7d807c7c1bea8e">inverse_chol</a> (X &amp;A)</td></tr>
<tr class="memdesc:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#a4fe9a133da033dadfa7d807c7c1bea8e">More...</a><br/></td></tr>
<tr class="separator:a4fe9a133da033dadfa7d807c7c1bea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memTemplItemLeft" align="right" valign="top">static X &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#af58ae9a2c9bc2666f7b1acda0d3c10d9">inverse_SPD</a> (X &amp;A)</td></tr>
<tr class="memdesc:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the symmetric, positive-definite matrix A using Cholesky factorization.  <a href="#af58ae9a2c9bc2666f7b1acda0d3c10d9">More...</a><br/></td></tr>
<tr class="separator:af58ae9a2c9bc2666f7b1acda0d3c10d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade83dd024356abd113ec323b1ae15b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade83dd024356abd113ec323b1ae15b53"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#ade83dd024356abd113ec323b1ae15b53">workM</a></td></tr>
<tr class="memdesc:ade83dd024356abd113ec323b1ae15b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrices <br/></td></tr>
<tr class="separator:ade83dd024356abd113ec323b1ae15b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cde9530852ad271620e4c01bd7bd3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0cde9530852ad271620e4c01bd7bd3f"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workM2</b></td></tr>
<tr class="separator:af0cde9530852ad271620e4c01bd7bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bef0f02f855cd773656a831ed56af0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68bef0f02f855cd773656a831ed56af0"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a68bef0f02f855cd773656a831ed56af0">U</a></td></tr>
<tr class="memdesc:a68bef0f02f855cd773656a831ed56af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrix (for SVD) <br/></td></tr>
<tr class="separator:a68bef0f02f855cd773656a831ed56af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9d29e3a6a887ec99e3efc430758c62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f9d29e3a6a887ec99e3efc430758c62"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; std::vector<br class="typebreak"/>
&lt; INTEGER &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a1f9d29e3a6a887ec99e3efc430758c62">pivwork</a></td></tr>
<tr class="memdesc:a1f9d29e3a6a887ec99e3efc430758c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">work STL integer vector (pivoting) <br/></td></tr>
<tr class="separator:a1f9d29e3a6a887ec99e3efc430758c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baea3b38a2daf859802100431863714"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5baea3b38a2daf859802100431863714"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a5baea3b38a2daf859802100431863714">V</a></td></tr>
<tr class="memdesc:a5baea3b38a2daf859802100431863714"><td class="mdescLeft">&#160;</td><td class="mdescRight">work matrix (for SVD) <br/></td></tr>
<tr class="separator:a5baea3b38a2daf859802100431863714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9de9f5b44a86ce33b0a8a7babd427b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f9de9f5b44a86ce33b0a8a7babd427b"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a4f9de9f5b44a86ce33b0a8a7babd427b">S</a></td></tr>
<tr class="memdesc:a4f9de9f5b44a86ce33b0a8a7babd427b"><td class="mdescLeft">&#160;</td><td class="mdescRight">work vector (for SVD/eigenvalues) <br/></td></tr>
<tr class="separator:a4f9de9f5b44a86ce33b0a8a7babd427b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee055dbb39a7334447a0145214235ebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee055dbb39a7334447a0145214235ebe"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#aee055dbb39a7334447a0145214235ebe">workv</a></td></tr>
<tr class="memdesc:aee055dbb39a7334447a0145214235ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">work vectors (LAPACK routines) <br/></td></tr>
<tr class="separator:aee055dbb39a7334447a0145214235ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f412f9cce018240b397ca8640064368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f412f9cce018240b397ca8640064368"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; <a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>workv2</b></td></tr>
<tr class="separator:a1f412f9cce018240b397ca8640064368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b24641a8db6c4bf027fe0ad3e97cd09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b24641a8db6c4bf027fe0ad3e97cd09"></a>
<a class="el" href="classRavelin_1_1FastThreadable.html">FastThreadable</a>&lt; std::vector<br class="typebreak"/>
&lt; INTEGER &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRavelin_1_1LINALG.html#a6b24641a8db6c4bf027fe0ad3e97cd09">iworkv</a></td></tr>
<tr class="memdesc:a6b24641a8db6c4bf027fe0ad3e97cd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">work STL integer vector (LAPACK routines) <br/></td></tr>
<tr class="separator:a6b24641a8db6c4bf027fe0ad3e97cd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Linear algebra routines. </p>
<p>LinAlg is a set of static routines that interface to LAPACK. I have included only very few routines here, however they should be some of the most utilized: SVD, (SVD-based) pseudo-inverse, linear equation solving, and matrix inverse. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4cce23867c57939239cb95d9428ef324"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::eig_symm </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4cce23867c57939239cb95d9428ef324"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::eig_symm </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a421a723477d6c49be0a165d87421ad1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::eig_symm_plus </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A_evecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues and eigenvectors of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square symmetric matrix on input, eigenvectors corresponding to eigenvalues on return </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a421a723477d6c49be0a165d87421ad1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::eig_symm_plus </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A_evecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>evals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the eigenvalues and eigenvectors of the matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square symmetric matrix on input, eigenvectors corresponding to eigenvalues on return </td></tr>
    <tr><td class="paramname">evals</td><td>on return, the eigenvalues will be stored here in ascending order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b96c22a3b9c0694210078a38798f56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ravelin::LINALG::factor_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the Cholesky factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix A on input; the factorized (upper triangular) matrix on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if matrix factored successfully, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1b96c22a3b9c0694210078a38798f56a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ravelin::LINALG::factor_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the Cholesky factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix A on input; the factorized (upper triangular) matrix on output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if matrix factored successfully, <b>false</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8ad92632041940ca3d948b55367baa3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ravelin::LINALG::factor_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the LU factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the m x n matrix to be factored; on exit, the factors L and U from the factorization M = P*L*U (unit diagonal elements of L are not stored) </td></tr>
    <tr><td class="paramname">pivwork</td><td>on output, contains the pivot indices (for 1 &lt;= i &lt;= min(m,n), row i of A was interchanged with row pivwork[i]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if A is singular, <b>true</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8ad92632041940ca3d948b55367baa3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Ravelin::LINALG::factor_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the LU factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the m x n matrix to be factored; on exit, the factors L and U from the factorization M = P*L*U (unit diagonal elements of L are not stored) </td></tr>
    <tr><td class="paramname">pivwork</td><td>on output, contains the pivot indices (for 1 &lt;= i &lt;= min(m,n), row i of A was interchanged with row pivwork[i]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>false</b> if A is singular, <b>true</b> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac3caea18d7a91a311635e86f62c28bcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>PI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix with column pivoting. </p>
<p>Factorizes A*P = Q*R </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the matrix A on input; the matrix R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the matrix Q on output </td></tr>
    <tr><td class="paramname">PI</td><td>the column pivots on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3caea18d7a91a311635e86f62c28bcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>PI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix with column pivoting. </p>
<p>Factorizes A*P = Q*R </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the matrix A on input; the matrix R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the matrix Q on output </td></tr>
    <tr><td class="paramname">PI</td><td>the column pivots on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09095d33d0b06a94b3ef08322ec53dee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the m x n matrix A on input; the matrix min(m,n) x n R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the m x min(m,n) matrix Q on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09095d33d0b06a94b3ef08322ec53dee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ARMat , class QMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::factor_QR </td>
          <td>(</td>
          <td class="paramtype">ARMat &amp;&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the QR factorization of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">AQ</td><td>the m x n matrix A on input; the matrix min(m,n) x n R on output </td></tr>
    <tr><td class="paramname">Q</td><td>the m x min(m,n) matrix Q on output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fe9a133da033dadfa7d807c7c1bea8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::inverse_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the Cholesky factorization of a matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4fe9a133da033dadfa7d807c7c1bea8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::inverse_chol </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the Cholesky factorization of a matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63829e76a2aa425ffe758e4c839fb587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::inverse_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a matrix inverse using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU-factored matrix </td></tr>
    <tr><td class="paramname">pivwork</td><td>the pivots determined by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>throws <a class="el" href="classRavelin_1_1SingularException.html" title="Exception thrown when trying to invert/solve with a non-invertible matrix. ">SingularException</a> if matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="a63829e76a2aa425ffe758e4c839fb587"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::inverse_LU </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes a matrix inverse using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU-factored matrix </td></tr>
    <tr><td class="paramname">pivwork</td><td>the pivots determined by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>throws <a class="el" href="classRavelin_1_1SingularException.html" title="Exception thrown when trying to invert/solve with a non-invertible matrix. ">SingularException</a> if matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="af58ae9a2c9bc2666f7b1acda0d3c10d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::inverse_SPD </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric positive-definite matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af58ae9a2c9bc2666f7b1acda0d3c10d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::inverse_SPD </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, positive-definite matrix A using Cholesky factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric positive-definite matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43e0ec1fe8292d9e201c5af1b69ad3a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::inverse_symmetric </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, indefinite matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric indefinite matrix; inverse will be contained here on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43e0ec1fe8292d9e201c5af1b69ad3a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::inverse_symmetric </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the symmetric, indefinite matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square, symmetric indefinite matrix; inverse will be contained here on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7b9e0c17e94c903516a33a109d434e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::invert </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the matrix A using LU factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7b9e0c17e94c903516a33a109d434e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::invert </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts the matrix A using LU factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix; contains the inverse on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab31076b4febea7112684caa16ce1b429"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a>&amp; Ravelin::LINALG::nullspace </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>nullspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nullspace of a matrix. </p>
<dl class="section note"><dt>Note</dt><dd>A is destroyed on return </dd></dl>

</div>
</div>
<a class="anchor" id="ab31076b4febea7112684caa16ce1b429"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a>&amp; Ravelin::LINALG::nullspace </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>nullspace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the nullspace of a matrix. </p>
<dl class="section note"><dt>Note</dt><dd>A is destroyed on return </dd></dl>

</div>
</div>
<a class="anchor" id="aa8e40ab11ab89d1041f9ffbe25131901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_chol_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the Cholesky decomposition performed by <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8e40ab11ab89d1041f9ffbe25131901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_chol_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the Cholesky decomposition performed by <a class="el" href="classRavelin_1_1LINALG.html#a1b96c22a3b9c0694210078a38798f56a" title="Performs the Cholesky factorization of a matrix. ">factor_chol()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a489a0d62b0192872b88e9754fc8c145c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Y&amp; Ravelin::LINALG::solve_fast </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the general system AX = B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a489a0d62b0192872b88e9754fc8c145c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Y&amp; Ravelin::LINALG::solve_fast </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the general system AX = B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a square matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83420fa6d087a3b62c1ddd510a2a6fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_LDL_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves systems of linear equations using the factorization determined via factor_LDL() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the factorization performed by factor_LDL() </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83420fa6d087a3b62c1ddd510a2a6fd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_LDL_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves systems of linear equations using the factorization determined via factor_LDL() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the factorization performed by factor_LDL() </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand sides on input, the vectors X on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad16e124bf2b16f8d796d4d81c59f0412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y , class Vec , class Z &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>(REAL)&#160;-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad16e124bf2b16f8d796d4d81c59f0412"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y , class Vec , class Z &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vec &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Z &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em> = <code>(REAL)&#160;-1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a257c49da86397d54e6687e98c2af53fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SVD&#160;</td>
          <td class="paramname"><em>svd_algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a257c49da86397d54e6687e98c2af53fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_LS_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SVD&#160;</td>
          <td class="paramname"><em>svd_algo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">REAL&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Most robust system of linear equations solver (solves AX = B) </p>
<p>Solves rank-deficient and underdetermined (minimum norm solution) systems. Computes least-squares solution to overdetermined systems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the coefficient matrix (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the matrix B on input, the matrix X on return </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance for determining the rank of A; if tol &lt; 0.0, tol is computed using machine epsilon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e2ff962b1fcc9df4a7411681bbbd901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_LU_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU factorization performed by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the matrix X on return </td></tr>
    <tr><td class="paramname">transpose</td><td>if <b>true</b>, solves M'X = B </td></tr>
    <tr><td class="paramname">pivwork</td><td>pivots computed by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e2ff962b1fcc9df4a7411681bbbd901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_LU_fast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of linear equations using the factorization determined via <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the LU factorization performed by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the matrix X on return </td></tr>
    <tr><td class="paramname">transpose</td><td>if <b>true</b>, solves M'X = B </td></tr>
    <tr><td class="paramname">pivwork</td><td>pivots computed by <a class="el" href="classRavelin_1_1LINALG.html#a8ad92632041940ca3d948b55367baa3c" title="Performs the LU factorization of a matrix. ">factor_LU()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac91f90a5921fd6d630930b79673d3bd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_SPD_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of equations A*X = B using a symmetric, positive-definite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix coefficients; this matrix will be destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>on input B, on output X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac91f90a5921fd6d630930b79673d3bd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_SPD_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a system of equations A*X = B using a symmetric, positive-definite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix coefficients; this matrix will be destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>on input B, on output X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a691ab0e0f1e84082845b04ced2ffb028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_symmetric_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a symmetric, indefinite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix to be solved; the matrix is destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>the RHS B (A*X = B) on input; the solution, X, on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a691ab0e0f1e84082845b04ced2ffb028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">X&amp; Ravelin::LINALG::solve_symmetric_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1MATRIXN.html">MATRIXN</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a symmetric, indefinite square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix to be solved; the matrix is destroyed on return </td></tr>
    <tr><td class="paramname">XB</td><td>the RHS B (A*X = B) on input; the solution, X, on return </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abed5ecdd3ed3a1215d02d4b2597fe1d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_tri_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a triangular system of linear equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix </td></tr>
    <tr><td class="paramname">utri</td><td>if <b>true</b> A is upper triangular (lower triangular otherwise) </td></tr>
    <tr><td class="paramname">transpose_A</td><td>if <b>true</b>, solves A'*x = b </td></tr>
    <tr><td class="paramname">XB</td><td>contains b on entry, x on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to XB </dd></dl>

</div>
</div>
<a class="anchor" id="abed5ecdd3ed3a1215d02d4b2597fe1d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_tri_fast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transpose_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a triangular system of linear equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix </td></tr>
    <tr><td class="paramname">utri</td><td>if <b>true</b> A is upper triangular (lower triangular otherwise) </td></tr>
    <tr><td class="paramname">transpose_A</td><td>if <b>true</b>, solves A'*x = b </td></tr>
    <tr><td class="paramname">XB</td><td>contains b on entry, x on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to XB </dd></dl>

</div>
</div>
<a class="anchor" id="af6f19314b8bb550e4fec001c1638742c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_tridiagonal_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a tridiagonal system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dl</td><td>the (n-1) elements on the subdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">d</td><td>the n elements on the diagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">du</td><td>the n elements on the superdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the solution on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution throws <a class="el" href="classRavelin_1_1SingularException.html" title="Exception thrown when trying to invert/solve with a non-invertible matrix. ">SingularException</a> if the matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="af6f19314b8bb550e4fec001c1638742c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static X&amp; Ravelin::LINALG::solve_tridiagonal_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>dl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRavelin_1_1VECTORN.html">VECTORN</a> &amp;&#160;</td>
          <td class="paramname"><em>du</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>XB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a tridiagonal system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dl</td><td>the (n-1) elements on the subdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">d</td><td>the n elements on the diagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">du</td><td>the n elements on the superdiagonal (destroyed on return) </td></tr>
    <tr><td class="paramname">XB</td><td>the right hand side on input, the solution on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution throws <a class="el" href="classRavelin_1_1SingularException.html" title="Exception thrown when trying to invert/solve with a non-invertible matrix. ">SingularException</a> if the matrix is singular </dd></dl>

</div>
</div>
<a class="anchor" id="a55d558061ab8c4992263e19699e9f028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::svd1 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A) </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55d558061ab8c4992263e19699e9f028"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::svd1 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A) </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c1e15257393585700d63837be294947"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::svd2 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A), using divide and conquer algorithm. </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c1e15257393585700d63837be294947"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class MatU , class VecS , class MatV &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ravelin::LINALG::svd2 </td>
          <td>(</td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does an 'in place' SVD (destroying A), using divide and conquer algorithm. </p>
<p>The singular value decomposition of A is U*S*V' (' is the transpose operator); to recompose A, it will be necessary to transpose V before multiplication (i.e., V is returned by the algorithm, not V'). Note: passed matrices and vectors U, S, and V are resized as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the matrix on which the SVD will be performed (destroyed on return) </td></tr>
    <tr><td class="paramname">U</td><td>on output, a A.rows() x A.rows() orthogonal matrix </td></tr>
    <tr><td class="paramname">S</td><td>on output, a min(A.rows(), A.columns()) length vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>on output, a A.columns() x A.columns() orthogonal matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/drum/Ravelin.new/include/Ravelin/<a class="el" href="LinAlgd_8h_source.html">LinAlgd.h</a></li>
<li>/home/drum/Ravelin.new/include/Ravelin/<a class="el" href="LinAlgf_8h_source.html">LinAlgf.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 9 2016 11:34:06 for Ravelin by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
